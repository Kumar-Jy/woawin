name: UUP to ISO Builder

on:
  workflow_dispatch:
    inputs:
      download_url:
        description: 'Download URL for UUP dump ZIP file'
        required: true
        type: string

env:
  WORK_DIR: woawin
  COMPRESSION_LEVEL: 6

jobs:
  build-iso:
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup working directory
        shell: powershell
        run: |
          $workDir = "${{ runner.temp }}\${{ env.WORK_DIR }}"
          New-Item -ItemType Directory -Path $workDir -Force | Out-Null
          Write-Host "Working directory created: $workDir"
          "WORK_DIR=$workDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Download UUP dump ZIP from link
        shell: powershell
        run: |
          $downloadUrl = "${{ github.event.inputs.download_url }}"
          Write-Host "Downloading from: $downloadUrl"
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          $ProgressPreference = 'SilentlyContinue'
          $outputPath = "${{ env.WORK_DIR }}\uup.zip"
          try {
            Invoke-WebRequest -Uri $downloadUrl -OutFile $outputPath -UseBasicParsing
            $fileSize = (Get-Item $outputPath).Length
            Write-Host "Download complete: $outputPath"
            Write-Host "File size: $([Math]::Round($fileSize / 1MB, 2)) MB"
          } catch {
            Write-Host "ERROR: Failed to download file: $_"
            exit 1
          }

      - name: Extract UUP dump ZIP
        shell: powershell
        run: |
          $zipPath = "${{ env.WORK_DIR }}\uup.zip"
          $extractPath = "${{ env.WORK_DIR }}\uup-extract"
          try {
            Write-Host "Extracting to: $extractPath"
            Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
            Write-Host "Extraction complete"
          } catch {
            Write-Host "ERROR: Failed to extract: $_"
            exit 1
          }

      - name: Run conversion script
        shell: powershell
        run: |
          $extractPath = "${{ env.WORK_DIR }}\uup-extract"
          $scriptPath = Join-Path $extractPath "uup_download_windows.cmd"
            if (Test-Path $scriptPath) {
              Write-Host "Running script: $scriptPath"
              Push-Location $extractPath
              try {
                & .\uup_download_windows.cmd
                $exitCode = $LASTEXITCODE
                if ($exitCode -ne 0) {
                  Write-Host "WARNING: Script exited with code: $exitCode"
                }
              } catch {
                Write-Host "ERROR: Failed to execute script: $_"
                exit 1
              } finally {
                Pop-Location
              }
            } else {
              Write-Host "ERROR: uup_download_windows.cmd not found at $scriptPath"
              exit 1
            }

      - name: Find ISO and set output
        id: find_iso
        shell: powershell
        run: |
          $extractPath = "${{ env.WORK_DIR }}\uup-extract"
          $isoFiles = Get-ChildItem -Path $extractPath -Filter *.iso -Recurse
          
          if ($isoFiles.Count -eq 0) {
            Write-Host "ERROR: No ISO files found in $extractPath"
            exit 1
          }
          
          $iso = $isoFiles[0]
          Write-Host "Found ISO: $($iso.FullName)"
          Write-Host "Size: $([Math]::Round($iso.Length / 1GB, 2)) GB"
          
          "iso_path=$($iso.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "iso_name=$($iso.Name)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "iso_size=$($iso.Length)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          $isoBaseName = [System.IO.Path]::GetFileNameWithoutExtension($iso.Name)
          "iso_base_name=$isoBaseName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Extract ISO contents to find install image
        shell: powershell
        run: |
          $isoPath = "${{ steps.find_iso.outputs.iso_path }}"
          $isoExtractDir = Join-Path "${{ env.WORK_DIR }}" "iso_contents"
          New-Item -ItemType Directory -Path $isoExtractDir -Force | Out-Null
          Write-Host "Extracting ISO contents..."
          & "C:\Program Files\7-Zip\7z.exe" x "$isoPath" -o"$isoExtractDir" -y
          if ($LASTEXITCODE -ne 0) {
            Write-Host "ERROR: ISO extraction failed"
            exit 1
          }
          Write-Host "ISO extraction complete"
          echo "ISO_EXTRACT_DIR=$isoExtractDir" >> $env:GITHUB_ENV

      - name: Find install.wim or install.esd
        id: find_install_file
        shell: powershell
        run: |
          $sourcesDir = Join-Path $env:ISO_EXTRACT_DIR "sources"
          if (-not (Test-Path $sourcesDir)) {
            Write-Host "ERROR: Sources directory not found"
            exit 1
          }
          $installWim = Get-ChildItem -Path $sourcesDir -Filter "install.wim" -ErrorAction SilentlyContinue | Select-Object -First 1
          $installEsd = Get-ChildItem -Path $sourcesDir -Filter "install.esd" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($installWim) {
            Write-Host "Found install.wim ($([Math]::Round($installWim.Length / 1GB, 2)) GB)"
            echo "install_file=$($installWim.FullName)" >> $env:GITHUB_OUTPUT
            echo "install_type=wim" >> $env:GITHUB_OUTPUT
          } elseif ($installEsd) {
            Write-Host "Found install.esd ($([Math]::Round($installEsd.Length / 1GB, 2)) GB)"
            echo "install_file=$($installEsd.FullName)" >> $env:GITHUB_OUTPUT
            echo "install_type=esd" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "ERROR: No install.wim or install.esd found"
            exit 1
          }

      - name: Parse editions from install image
        id: parse_images
        shell: powershell
        run: |
          $installFile = "${{ steps.find_install_file.outputs.install_file }}"
          Write-Host "Getting image information..."
          $wimInfo = dism /Get-WimInfo /WimFile:"$installFile" 2>&1 | Out-String
          Write-Host $wimInfo
          $indexes = @()
          $lines = $wimInfo -split "`n"
          $currentIndex = $null
          $currentName = $null
          foreach ($line in $lines) {
            if ($line -match "Index\s*:\s*(\d+)") {
              $currentIndex = [int]$matches[1]
            }
            if ($line -match "Name\s*:\s*(.+)") {
              $currentName = $matches[1].Trim()
              if ($currentIndex -ne $null) {
                $indexes += [PSCustomObject]@{
                  Index = $currentIndex
                  Name = $currentName
                }
              }
            }
          }
          $proIndexes = @()
          $otherIndexes = @()
          foreach ($idx in $indexes) {
            if ($idx.Name -like "*Pro*") {
              $proIndexes += $idx.Index
            } else {
              $otherIndexes += $idx.Index
            }
          }
          Write-Host "Pro Edition Indexes: $($proIndexes -join ', ')"
          Write-Host "Other Edition Indexes: $($otherIndexes -join ', ')"
          echo "pro_indexes=$($proIndexes -join ',')" >> $env:GITHUB_OUTPUT
          echo "other_indexes=$($otherIndexes -join ',')" >> $env:GITHUB_OUTPUT
          echo "pro_count=$($proIndexes.Count)" >> $env:GITHUB_OUTPUT
          echo "other_count=$($otherIndexes.Count)" >> $env:GITHUB_OUTPUT
          echo "all_indexes=$($indexes | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT

      - name: Create new ESD with mixed indexes or rename original
        id: create_mixed_or_rename
        shell: powershell
        run: |
          $installFile = "${{ steps.find_install_file.outputs.install_file }}"
          $outputEsd = Join-Path $env:WORK_DIR "new_install.esd"
          $isoBaseName = "${{ steps.find_iso.outputs.iso_base_name }}"
          $installType = "${{ steps.find_install_file.outputs.install_type }}"
          $proIndexesStr = "${{ steps.parse_images.outputs.pro_indexes }}"
          $otherIndexesStr = "${{ steps.parse_images.outputs.other_indexes }}"
          $proCount = [int]"${{ steps.parse_images.outputs.pro_count }}"
          $otherCount = [int]"${{ steps.parse_images.outputs.other_count }}"
          $allIndexesJson = '${{ steps.parse_images.outputs.all_indexes }}'
          $proIndexes = if ($proIndexesStr) { $proIndexesStr.Split(',') | ForEach-Object { [int]$_ } } else { @() }
          $otherIndexes = if ($otherIndexesStr) { $otherIndexesStr.Split(',') | ForEach-Object { [int]$_ } } else { @() }
          $allIndexes = if ($allIndexesJson) { $allIndexesJson | ConvertFrom-Json } else { @() }
          if ($proCount -eq 0) {
            Write-Host "No Pro editions found. Copying original install file as final named file."
            $finalName = "${isoBaseName}.$installType"
            $finalPath = Join-Path $env:WORK_DIR $finalName
            Copy-Item -Path $installFile -Destination $finalPath -Force
            if (-not (Test-Path $finalPath)) {
              Write-Host "ERROR: Failed to copy original install file."
              exit 1
            }
            echo "final_esd_path=$finalPath" >> $env:GITHUB_OUTPUT
            echo "final_esd_name=$finalName" >> $env:GITHUB_OUTPUT
            exit 0
          }
          $sourceProIndex = $proIndexes[0]
          if ($otherCount -eq 0) {
            Write-Host "Pro edition(s) found but no other editions. Exporting Pro to all 6 indexes."
            for ($targetIndex = 1; $targetIndex -le 6; $targetIndex++) {
              Write-Host "Exporting Pro edition to index $targetIndex"
              dism /Export-Image /SourceImageFile:"$installFile" /SourceIndex:$sourceProIndex /DestinationImageFile:"$outputEsd" /Compress:recovery /CheckIntegrity
              if ($LASTEXITCODE -ne 0) {
                Write-Host "ERROR: Export failed at index $targetIndex"
                exit 1
              }
            }
          }
          else {
            Write-Host "Both Pro and other editions found. Export Pro to 1,2,3,5,6 and Other (prefer Home) to index 4."
            $homeIndex = $null
            foreach ($idx in $allIndexes) {
              if ($idx.Name -like "*Home*") {
                $homeIndex = $idx.Index
                Write-Host "Found Home edition at index $homeIndex"
                break
              }
            }
            $index4 = if ($homeIndex) { $homeIndex } else { $otherIndexes[0] }
            Write-Host "Using index $index4 for index 4"
            $exportSequence = @(
              @{Index=1; Source=$sourceProIndex},
              @{Index=2; Source=$sourceProIndex},
              @{Index=3; Source=$sourceProIndex},
              @{Index=4; Source=$index4},
              @{Index=5; Source=$sourceProIndex},
              @{Index=6; Source=$sourceProIndex}
            )
            for ($i=0; $i -lt $exportSequence.Count; $i++) {
              $seq = $exportSequence[$i]
              $targetIndex = $seq.Index
              Write-Host "Exporting source index $($seq.Source) to target index $targetIndex"
              dism /Export-Image /SourceImageFile:"$installFile" /SourceIndex:$($seq.Source) /DestinationImageFile:"$outputEsd" /Compress:recovery /CheckIntegrity
              if ($LASTEXITCODE -ne 0) {
                Write-Host "ERROR: Export failed at target index $targetIndex"
                exit 1
              }
            }
          }
          $fileSize = (Get-Item $outputEsd).Length
          Write-Host "New ESD created: $([Math]::Round($fileSize / 1GB, 2)) GB"
          echo "new_esd_size=$fileSize" >> $env:GITHUB_OUTPUT
          echo "new_esd_path=$outputEsd" >> $env:GITHUB_OUTPUT

      - name: Set fallback ESD path if new not created
        id: set_esd_path
        shell: powershell
        run: |
          $finalEsdPath = "${{ steps.create_mixed_or_rename.outputs.final_esd_path }}"
          $newEsdPath = "${{ steps.create_mixed_or_rename.outputs.new_esd_path }}"
          $originalEsd = "${{ steps.find_install_file.outputs.install_file }}"
          if (-not $finalEsdPath) {
            if ($newEsdPath -and (Test-Path $newEsdPath)) {
              $finalEsdPath = $newEsdPath
            } else {
              Write-Host "Neither final nor new ESD path set; falling back to original install file."
              $finalEsdPath = $originalEsd
            }
          } else {
            if (-not (Test-Path $finalEsdPath)) {
              Write-Host "Final ESD path does not exist; falling back to original install file."
              $finalEsdPath = $originalEsd
            }
          }
          Write-Host "Final ESD path is: $finalEsdPath"
          echo "final_esd_path=$finalEsdPath" >> $env:GITHUB_OUTPUT

      - name: Rename ESD to ISO basename and get size
        id: rename_esd
        shell: powershell
        run: |
          $esdFile = "${{ steps.set_esd_path.outputs.final_esd_path }}"
          if (-not (Test-Path $esdFile)) {
            Write-Host "ERROR: ESD file not found at $esdFile"
            exit 1
          }
          $isoBaseName = "${{ steps.find_iso.outputs.iso_base_name }}"
          $currentName = Split-Path -Leaf $esdFile
          $ext = [System.IO.Path]::GetExtension($currentName)
          $renameTo = "${isoBaseName}${ext}"
          $finalPath = Join-Path (Split-Path -Parent $esdFile) $renameTo
          Rename-Item -Path $esdFile -NewName $renameTo -Force
          if (-not (Test-Path $finalPath)) {
            Write-Host "ERROR: Renamed ESD not found at $finalPath"
            exit 1
          }
          $fileObj = Get-Item $finalPath
          $fileSize = $fileObj.Length
          $fileSizeGB = [Math]::Round($fileSize / 1GB, 2)
          $fileSizeMB = [Math]::Round($fileSize / 1MB, 2)
          Write-Host "Renamed to: $renameTo"
          Write-Host "ESD size: $fileSizeGB GB ($fileSizeMB MB)"
          echo "final_esd_path=$finalPath" >> $env:GITHUB_OUTPUT
          echo "final_esd_name=$renameTo" >> $env:GITHUB_OUTPUT
          echo "final_esd_size=$fileSize" >> $env:GITHUB_OUTPUT
          echo "final_esd_size_gb=$fileSizeGB" >> $env:GITHUB_OUTPUT
          echo "final_esd_size_mb=$fileSizeMB" >> $env:GITHUB_OUTPUT

      - name: Calculate ISO checksums
        id: iso_hashes
        shell: powershell
        run: |
          $isoPath = "${{ steps.find_iso.outputs.iso_path }}"
          Write-Host "Calculating MD5, SHA1, SHA256 for ISO: $isoPath"
          $md5 = (Get-FileHash $isoPath -Algorithm MD5).Hash.ToLower()
          $sha1 = (Get-FileHash $isoPath -Algorithm SHA1).Hash.ToLower()
          $sha256 = (Get-FileHash $isoPath -Algorithm SHA256).Hash.ToLower()
          "md5=$md5" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "sha1=$sha1" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "sha256=$sha256" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Print final ESD indexes
        shell: powershell
        run: |
          $finalEsd = "${{ steps.rename_esd.outputs.final_esd_path }}"
          Write-Host "Getting NEW ESD image information..."
          $wimInfo = dism /Get-WimInfo /WimFile:"$finalEsd" 2>&1 | Out-String
          Write-Host $wimInfo
          $indexes = @()
          $lines = $wimInfo -split "`n"
          $currentIndex = $null
          $currentName = $null
          foreach ($line in $lines) {
            if ($line -match "Index\s*:\s*(\d+)") {
              $currentIndex = [int]$matches[1]
            }
            if ($line -match "Name\s*:\s*(.+)") {
              $currentName = $matches[1].Trim()
              if ($currentIndex -ne $null) {
                $indexes += [PSCustomObject]@{
                  Index = $currentIndex
                  Name = $currentName
                }
                Write-Host "${currentIndex}: ${currentName}"
              }
            }
          }
          
      - name: Calculate ESD checksums
        id: esd_hashes
        shell: powershell
        run: |
          $esdPath = "${{ steps.rename_esd.outputs.final_esd_path }}"
          if (-not (Test-Path $esdPath)) {
            Write-Host "ERROR: ESD file not found at $esdPath"
            exit 1
          }
          Write-Host "Calculating MD5, SHA1, SHA256 for ESD: $esdPath"
          $md5 = (Get-FileHash $esdPath -Algorithm MD5).Hash.ToLower()
          $sha1 = (Get-FileHash $esdPath -Algorithm SHA1).Hash.ToLower()
          $sha256 = (Get-FileHash $esdPath -Algorithm SHA256).Hash.ToLower()
          "esd_md5=$md5" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "esd_sha1=$sha1" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "esd_sha256=$sha256" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          
      - name: Generate unique release tag and date
        id: gen_tag
        shell: powershell
        run: |
          $tag = Get-Date -Format "yyyy-MM-dd_HHmmss"
          $name = Get-Date -Format "MMMM dd, yyyy HH:mm:ss"
          "release_tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "release_name=$name" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Split ESD into parts
        id: split_esd
        shell: powershell
        run: |
          $esdPath = "${{ steps.rename_esd.outputs.final_esd_path }}"
          if (-not (Test-Path $esdPath)) {
            Write-Host "ERROR: ESD file not found at $esdPath"
            exit 1
          }
          $esdSize = (Get-Item $esdPath).Length
          $esdName = "${{ steps.rename_esd.outputs.final_esd_name }}"
          $splitOutputDir = Split-Path $esdPath
          $esdBaseName = [System.IO.Path]::GetFileNameWithoutExtension($esdName)
          $splitArchiveName = "${esdBaseName}_parts"
          $splitArchivePath = Join-Path $splitOutputDir "$splitArchiveName.zip"
          Write-Host "Splitting ESD into 2000MB parts..."
          Write-Host "ESD Path: $esdPath"
          Write-Host "ESD Size: $([Math]::Round($esdSize / 1073741824, 2)) GB"
          Write-Host "Archive name: $splitArchiveName"
          try {
            & "C:\Program Files\7-Zip\7z.exe" a -tzip -mx=${{ env.COMPRESSION_LEVEL }} -mmt=on $splitArchivePath -v2000m $esdPath
            if ($LASTEXITCODE -ne 0) {
              Write-Host "ERROR: 7-Zip compression failed with exit code: $LASTEXITCODE"
              exit 1
            }
          } catch {
            Write-Host "ERROR: Failed to split ESD: $_"
            exit 1
          }
          $splitPattern = "${splitArchiveName}.zip.00*"
          $parts = Get-ChildItem -Path $splitOutputDir -Filter $splitPattern | Sort-Object Name
          if ($parts.Count -eq 0) {
            Write-Host "ERROR: No split files found with pattern: $splitPattern"
            exit 1
          }
          Write-Host "Split ESD parts created:"
          $parts | ForEach-Object { Write-Host " - $($_.Name) ($([Math]::Round($_.Length / 1MB, 2)) MB)" }
          $sizeGB = [Math]::Round($esdSize / 1073741824, 2)
          $isoSizeBytes = [int64] "${{ steps.find_iso.outputs.iso_size }}"
          $isoSizeGB = [Math]::Round($isoSizeBytes / 1GB, 2)
          $workflowRunUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          $desc = @"

          ### **Build Date**: ``$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')``
          ### **âš¡Download Complete ISO or ESD in one zip file (need extract)**: [``from this build Action Run``]($workflowRunUrl)      
          ### ISO File Details:
          - **Name**: ``"${{ steps.find_iso.outputs.iso_name }}"``
          - **MD5**: ``${{ steps.iso_hashes.outputs.md5 }}``
          - **SHA1**: ``${{ steps.iso_hashes.outputs.sha1 }}``
          - **SHA256**: ``${{ steps.iso_hashes.outputs.sha256 }}``
          - **Size**: ``$isoSizeGB GB ($isoSizeBytes bytes)``
          
          ### ESD File Details:
          - **Name**: ``$esdName``
          - **MD5**: ``${{ steps.esd_hashes.outputs.esd_md5 }}``
          - **SHA1**: ``${{ steps.esd_hashes.outputs.esd_sha1 }}``
          - **SHA256**: ``${{ steps.esd_hashes.outputs.esd_sha256 }}``
          - **Size**: ``$sizeGB GB ($esdSize bytes)``
          
          ## ESD Part List (Download from here):
          
          "@
          
          $desc += ($parts | ForEach-Object { "- **[``$($_.Name)``](https://github.com/$env:GITHUB_REPOSITORY/releases/download/${{ steps.gen_tag.outputs.release_tag }}/$($_.Name)) - $([Math]::Round($_.Length / 1MB, 2)) MB**" }) -join "`n"
          
          $desc += @"
          
          ## Extraction Instructions:
          - ### Download all ESD parts
          - ### Use 7-Zip or WinRAR to extract: Right-click on ``$($parts[0].Name)`` -> Extract Here
          - ### The full ESD will be extracted automatically
          
          ## One-Click Extraction
          Copy and paste this in the cmd/termux terminal and wait, it will automatically download and extract the esd image in the Download folder.

          - ### Windows ( CMD )
          ```
          curl -LO https://github.com/$env:GITHUB_REPOSITORY/releases/download/${{ steps.gen_tag.outputs.release_tag }}/extractor.cmd && extractor.cmd
          ```
          - ### Android ( Termux )
          ```
          curl -LO https://github.com/$env:GITHUB_REPOSITORY/releases/download/${{ steps.gen_tag.outputs.release_tag }}/extractor.sh && chmod +x extractor.sh && ./extractor.sh
          ```
          
          "@
          
          $descPath = Join-Path $splitOutputDir "release_description.txt"
          Set-Content -Path $descPath -Value $desc -Encoding utf8
          echo "split_dir=$splitOutputDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "split_pattern=$splitPattern" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "parts_count=$($parts.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          $firstPart = $parts[0].Name
          $zip001Url = "https://github.com/$env:GITHUB_REPOSITORY/releases/download/${{ steps.gen_tag.outputs.release_tag }}/$firstPart"
          if ($zip001Url) { "zip001_url=$zip001Url" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8 }

      - name: Generate Windows extractor.cmd
        shell: powershell
        run: |
          $url = "${{ steps.split_esd.outputs.zip001_url }}"

          $cmd = @"
          @echo off
          setlocal EnableDelayedExpansion

          :: Auto elevate
          net session >nul 2>&1 || (
          powershell -Command "Start-Process '%~f0' -Verb RunAs"
          exit /b
          )

          set ZIP001=$url
          set WKDIR=%USERPROFILE%\Downloads
          set DL=%WKDIR%\dl
          set TOOLS=%WKDIR%\tools
          mkdir "%DL%" "%TOOLS%" >nul 2>&1

          set SEVENZIP=%TOOLS%\7zr.exe
          if not exist "%SEVENZIP%" (
          echo Downloading 7-Zip...
          curl -L -o "%SEVENZIP%" https://www.7-zip.org/a/7zr.exe || exit /b 1
          )

          for %%A in ("%ZIP001%") do set FILE=%%~nxA
          set BASE=%ZIP001%
          set EXT=%FILE:~-4%

          if /I "%EXT%"==".001" set BASE=%ZIP001:.001=%
          if /I "%EXT%"==".z01" set BASE=%ZIP001:.z01=%

          set i=1
          :dl
          set p=00%i%
          set p=!p:~-3!
          if /I "%EXT%"==".z01" set p=z!p:~-2!

          curl -f -L -C - "%BASE%.!p!" -o "%DL%\%FILE:~0,-4%.!p!" || goto extract

          set /a i+=1
          goto dl

          :extract
          "%SEVENZIP%" x "%DL%\%FILE%" -o"%DL%" -y
          echo Done.
          pause
          "@

          Set-Content extractor.cmd $cmd -Encoding ASCII

      - name: Generate Termux extractor.sh
        shell: bash
        run: |
          URL="${{ steps.split_esd.outputs.zip001_url }}"

          cat > extractor.sh <<EOF
          #!/data/data/com.termux/files/usr/bin/bash
          set -e

          ZIP001="$URL"
          DL="\$PWD/dl"
          mkdir -p "\$DL"

          ! command -v 7z >/dev/null 2>&1 && pkg update -y && pkg install -y p7zip curl

          NAME=\$(basename "\$ZIP001")
          BASE="\${ZIP001%.001}"
          [ "\${NAME: -4}" = ".z01" ] && BASE="\${ZIP001%.z01}"

          for i in \$(seq 1 10); do
           p=\$(printf "%03d" \$i)
           [ "\${NAME: -4}" = ".z01" ] && p="z\${p: -2}"
           PART_URL="\$BASE.\$p"
           PART_FILE="\$DL/\${NAME%.*}.\$p"
           echo "Downloading \$PART_URL ..."
           if ! curl -fL -C - "\$PART_URL" -o "\$PART_FILE"; then
            break
           fi
          done
  
          7z x "\$DL/\${NAME%.*}.001" -o"\$DL" -y
          echo "Done. Extracted to \$DL"
          
          echo "Copy windows image to Download folder"
          FILE=\$(find "\$DL" -maxdepth 1 -type f ! -name "*.00?" ! -name "*.z??" | head -1)
          [ -n "\$FILE" ] && rsync -ah --progress "\$FILE" "/storage/emulated/0/Download/" 2>/dev/null &&
           echo "Copied" && rm -rf "\$DL" || { echo "Failed to copy"; exit 1; }
          EOF 
          chmod +x extractor.sh

      - name: Create GitHub Release and upload split ESD parts
        shell: powershell
        run: |
          $splitDir = "${{ steps.split_esd.outputs.split_dir }}"
          $splitPattern = "${{ steps.split_esd.outputs.split_pattern }}"
          $releaseTag = "${{ steps.gen_tag.outputs.release_tag }}"
          $releaseName = "${{ steps.gen_tag.outputs.release_name }}"
          $parts = Get-ChildItem -Path $splitDir -Filter $splitPattern | Sort-Object Name
          if ($parts.Count -eq 0) {
            Write-Host "ERROR: No split files found"
            exit 1
          }
          Write-Host "Creating release: $releaseName"
          Write-Host "Uploading $($parts.Count) ESD parts"
          $descPath = Join-Path $splitDir "release_description.txt"
          $body = if (Test-Path $descPath) { Get-Content $descPath -Raw } else { "Build Release" }
          $fileArgs = @()
          $fileArgs += $parts | ForEach-Object { $_.FullName }
          $fileArgs += "extractor.cmd"
          $fileArgs += "extractor.sh"
          & gh release create $releaseTag `
            --title "Build - $releaseName" `
            --notes $body `
            $fileArgs
          if ($LASTEXITCODE -ne 0) {
            Write-Host "ERROR: Failed to create release"
            exit 1
          }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload original ISO to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ISO_${{ steps.find_iso.outputs.iso_base_name }}
          path: ${{ steps.find_iso.outputs.iso_path }}
          retention-days: 30
          if-no-files-found: error
          compression-level: ${{ env.COMPRESSION_LEVEL }}

      - name: Upload new ESD to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ESD_${{ steps.find_iso.outputs.iso_base_name }}
          path: ${{ steps.rename_esd.outputs.final_esd_path }}
          retention-days: 30
          if-no-files-found: error
          compression-level: ${{ env.COMPRESSION_LEVEL }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Google API Library
        run: pip install google-api-python-client google-auth-oauthlib requests

      - name: Upload Build to Google Drive
        shell: python
        env:
          CLIENT_ID: ${{ secrets.GDRIVE_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.GDRIVE_CLIENT_SECRET }}
          REFRESH_TOKEN: ${{ secrets.GDRIVE_REFRESH_TOKEN }}
          PARENT_ID: ${{ secrets.GDRIVE_PARENT_ID }}
          RELEASE_TAG: ${{ steps.gen_tag.outputs.release_tag }}
          ISO_PATH: ${{ steps.find_iso.outputs.iso_path }}
          ESD_PATH: ${{ steps.rename_esd.outputs.final_esd_path }}
          PYTHONUTF8: 1
        run: |
          import os, time, sys, io, socket, random
          sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
          
          from google.oauth2.credentials import Credentials
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from googleapiclient.errors import HttpError

          def safe_exit(msg):
              print(f"\n[WARN] {msg}")
              print("[INFO] Creating dummy links so Release Notes update doesn't crash.")
              with open("glinks.env", "w", encoding='utf-8') as f:
                  f.write(f"GDRIVE_FOLDER=https://drive.google.com/\n")
                  f.write(f"GDRIVE_ISO=https://drive.google.com/\n")
                  f.write(f"GDRIVE_ESD=https://drive.google.com/\n")
              sys.exit(0)

          try:
              print("Authenticating with Google Drive...", flush=True)
              creds = Credentials(None, refresh_token=os.environ['REFRESH_TOKEN'],
                                  client_id=os.environ['CLIENT_ID'],
                                  client_secret=os.environ['CLIENT_SECRET'],
                                  token_uri="https://oauth2.googleapis.com/token")
              drive = build('drive', 'v3', credentials=creds)
          except Exception as e:
              safe_exit(f"Authentication Failed: {e}")

          def execute_with_retry(request_object):
              max_retries = 10
              last_exception = None
              
              for attempt in range(max_retries):
                  try:
                      return request_object.execute()
                  except (HttpError, socket.timeout, Exception) as e:
                      last_exception = e
                      
                      wait = min(2 ** attempt, 30) + random.uniform(0, 1)
                      print(f"   [Retry {attempt+1}/{max_retries}] API Error: {e}. Waiting {wait:.1f}s...", flush=True)
                      time.sleep(wait)
              
              if last_exception:
                  raise last_exception
              raise Exception("Max retries exceeded")

          def make_public(file_id):
              try:
                  permission = {'type': 'anyone', 'role': 'reader'}
                  req = drive.permissions().create(fileId=file_id, body=permission, supportsAllDrives=True)
                  execute_with_retry(req)
                  
                  req_link = drive.files().get(fileId=file_id, fields='webViewLink', supportsAllDrives=True)
                  res = execute_with_retry(req_link)
                  return res.get('webViewLink')
              except Exception as e:
                  print(f"Warning: Could not make file public: {e}")
                  return "ERROR_GETTING_LINK"

          def create_folder(name, parent):
              parents_list = [parent] if parent else []
              meta = {'name': name, 'mimeType': 'application/vnd.google-apps.folder', 'parents': parents_list}
              req = drive.files().create(body=meta, fields='id', supportsAllDrives=True)
              file = execute_with_retry(req)
              return file.get('id')

          def upload_with_progress(path, folder_id):
              file_name = os.path.basename(path)
              total_size = os.path.getsize(path)
              media = MediaFileUpload(path, resumable=True)
              request = drive.files().create(body={'name': file_name, 'parents': [folder_id]}, media_body=media, fields='id', supportsAllDrives=True)
              
              print(f"\n[UPLOADING] {file_name} ({total_size / (1024*1024):.2f} MB)", flush=True)
              start_time = time.time()
              response = None
              retries = 0
              
              while response is None:
                  try:
                      status, response = request.next_chunk()
                      if status:
                          elapsed = time.time() - start_time
                          current_mb = status.resumable_progress / (1024 * 1024)
                          speed = (current_mb / elapsed) if elapsed > 0 else 0
                          print(f" >> {status.progress()*100:3.0f}% | {current_mb:7.2f} MB | {speed:6.2f} MB/s", flush=True)
                      retries = 0
                  except Exception as e:
                      retries += 1
                      if retries > 10:
                          raise e
                      print(f" [Chunk Error] {e}. Retrying chunk... ({retries}/10)", flush=True)
                      time.sleep(min(2**retries, 30))
                      
              return response.get('id')

          try:
              parent_id = os.environ['PARENT_ID']

              try:
                  print(f"Attempting to create folder in Parent ID: {parent_id}", flush=True)
                  release_folder = create_folder(os.environ['RELEASE_TAG'], parent_id)
              except HttpError as e:
                  if e.resp.status == 404:
                      print(f"\n[!] 404 Error: The PARENT_ID was not found (after 10 retries).", flush=True)
                      print("[INFO] Switching to fallback: Uploading to ROOT directory instead.", flush=True)
                      release_folder = create_folder(f"{os.environ['RELEASE_TAG']}_FALLBACK", None)
                  else:
                      raise e

              release_link = make_public(release_folder)
              
              iso_folder = create_folder("ISO", release_folder)
              esd_folder = create_folder("ESD", release_folder)
              time.sleep(7)
              
              iso_id = upload_with_progress(os.environ['ISO_PATH'], iso_folder)
              iso_link = make_public(iso_id)
              
              esd_id = upload_with_progress(os.environ['ESD_PATH'], esd_folder)
              esd_link = make_public(esd_id)

              print("\n" + "="*60)
              print(f"ESD DIRECT LINK: {esd_link}")
              print(f"ISO DIRECT LINK: {iso_link}")
              print(f"RELEASE FOLDER:  {release_link}")
              print("="*60)

              with open("glinks.env", "w", encoding='utf-8') as f:
                  f.write(f"GDRIVE_FOLDER={release_link}\n")
                  f.write(f"GDRIVE_ISO={iso_link}\n")
                  f.write(f"GDRIVE_ESD={esd_link}\n")
                  
          except Exception as main_e:
              safe_exit(f"Critical Script Failure: {main_e}")

      - name: Finalize Release Notes
        shell: pwsh
        run: |
          $releaseTag = "${{ steps.gen_tag.outputs.release_tag }}"
          $links = Get-Content "glinks.env" | ConvertFrom-StringData
          $descPath = "${{ steps.build_desc.outputs.desc_path }}"
          $body = [System.IO.File]::ReadAllText($descPath, [System.Text.Encoding]::UTF8)
          $body = $body.Replace("{{GDRIVE_FOLDER}}", $links.GDRIVE_FOLDER)
          $body = $body.Replace("{{GDRIVE_ISO}}", $links.GDRIVE_ISO)
          $body = $body.Replace("{{GDRIVE_ESD}}", $links.GDRIVE_ESD)
          [System.IO.File]::WriteAllText("final_desc.txt", $body, [System.Text.Encoding]::UTF8)
          & gh release edit $releaseTag --notes-file "final_desc.txt"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
